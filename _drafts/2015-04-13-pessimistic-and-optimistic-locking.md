---
# MUST HAVE BEG
layout: post
disqus_identifier: 20150413-pessimistic-and-optimistic-locking # DO NOT CHANGE THE VALUE ONCE SET
title: æ•°æ®åº“ä¸­çš„ä¹è§‚é”å’Œæ‚²è§‚é”
# MUST HAVE END

is_short: true
subtitle:
tags: 
- database
- JPA
date: 2015-04-13 19:13:00
image:
image_desc:
---

ğŸ˜ŠğŸ˜„â¤ï¸ğŸ‘ªğŸ’¯

Emojiæ˜¯unicodeçš„ä¸€éƒ¨åˆ†ï¼ŒUTF-8ç¼–ç ä¹Ÿæ˜¯å¯ä»¥è¡¨ç¤ºEmojiçš„ã€‚
æ¯”å¦‚ğŸ˜å¯¹åº”çš„unicodeæ˜¯`U+1F601`ï¼Œå¯¹åº”çš„UTF-8ç¼–ç æ˜¯`\xF0\x9F\x98\x81`ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨UTF-8ç¼–ç å­˜å‚¨çš„
æ–‡æœ¬ä¸­ï¼ˆæ¯”å¦‚HTMLæ–‡ä»¶ï¼‰ä¿å­˜Emojiè¡¨æƒ…ã€‚

###æ˜¾ç¤ºæ–‡æœ¬ä¸­çš„Emoji
æˆ‘ä»¬éœ€è¦ä¸€ç§å­—ä½“æ¥æ˜¾ç¤ºä»¥UTF-8ç¼–ç çš„Emojiè¡¨æƒ…ã€‚é€šå¸¸ï¼Œä¸€ç§å­—ä½“ä¸èƒ½æ˜¾ç¤ºæ‰€æœ‰çš„UTF-8ç¼–ç ã€‚ä¸èƒ½æ˜¾ç¤ºæ—¶ï¼Œé€šå¸¸
ä¼šæ˜¾ç¤ºæˆä¸€ä¸ªâ€œå°æ–¹å—â€ã€‚åœ¨è¾ƒæ–°çš„OS Xç³»ç»Ÿä¸Šï¼Œ`Apple Color Emoji`å­—ä½“å¯ä»¥æ˜¾ç¤ºEmojiè¡¨æƒ…ã€‚åœ¨è¾ƒæ–°çš„Windowsä¸Š
ï¼ˆæ¯”å¦‚Windows 7/8ï¼‰ï¼Œ`Segoe UI Symbol`å­—ä½“å¯ä»¥æ˜¾ç¤ºé»‘ç™½çš„Emojiè¡¨æƒ…ã€‚Windows 8ä¸Šå¯ä»¥ç”¨
`Segoe UI Emoji`å­—ä½“æ¥æ˜¾ç¤ºå½©è‰²çš„è¡¨æƒ…ã€‚

###æ˜¾ç¤ºç½‘é¡µä¸Šçš„Emoji
å¯¹äºç½‘é¡µå…ƒç´ ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡CSSå±æ€§`font-family`æ¥æŒ‡å®šï¼ˆä¸€ç³»åˆ—ï¼‰å­—ä½“ã€‚æ¯”å¦‚ï¼Œ

    font-family: Gill Sans Extrabold, sans-serif;

æ’åœ¨å‰é¢çš„å­—ä½“ä¼˜å…ˆçº§è¾ƒåé¢çš„é«˜ã€‚å¦‚æœç”¨æˆ·ç”µè„‘ä¸Šæ²¡æœ‰å®‰è£…ä¼˜å…ˆçº§é«˜çš„å­—ä½“ï¼Œé‚£ä¹ˆæ ¹æ®ä¼˜å…ˆçº§ä¾æ¬¡å°è¯•åç»­çš„
å­—ä½“ã€‚å¦‚æœæ‰€æœ‰çš„å­—ä½“éƒ½æ²¡æœ‰æ‰¾åˆ°ï¼Œé‚£ä¹ˆä½¿ç”¨æµè§ˆå™¨æä¾›çš„å­—ä½“ï¼ˆInitial value depends on user agentï¼‰ã€‚
åœ¨OS Xä¸Šï¼Œå¦‚æœfont-familyä¸­æ²¡æœ‰æŒ‡å®šå¯ä»¥æ˜¾ç¤ºEmojiçš„å­—ä½“ï¼ŒSafariæ˜¯å¯ä»¥æ­£å¸¸æ˜¾ç¤ºEmojiçš„ï¼Œè€ŒChromeåˆ™ä¸èƒ½ã€‚
è¿™æ˜¯å› ä¸ºè¿™ä¸¤ä¸ªæµè§ˆå™¨æä¾›çš„é»˜è®¤å­—ä½“æœ‰åŒºåˆ«ã€‚

ä¸ºäº†åœ¨Windowså’ŒOS Xä¸Šéƒ½èƒ½æ˜¾ç¤ºEmojiè¡¨æƒ…ï¼Œå¯ä»¥å‘font-familyé‡ŒåŠ å…¥`Apple Color Emoji`ï¼Œ`Segoe UI Emoji`ï¼Œ
å’Œ`Segoe UI Symbol`å­—ä½“ã€‚æ¯”å¦‚ï¼Œ

    font-family: Helvetica, arial, freesans, clean, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';

æœ€åæ•ˆæœå¦‚ä¸‹ï¼Œ       
Chrome on Windows 7       
<img src="../images/blog/chrome-win7-emoji.png" alt="chrome win7 emoji" title="chrome win7 emoji" style="display: block; width: 90px; margin-left: 0px; margin-right: 0px;">
IE 11 on Windows 7      
<img src="../images/blog/ie-win7-emoji.png" alt="ie win7 emoji" title="ie win7 emoji" style="display: block; width: 90px; margin-left: 0px; margin-right: 0px;">
Safari on OS X     
<img src="../images/blog/safari-osx-emoji-png.png" alt="safari osx emoji" title="safari osx emoji" style="display: block; width: 90px; margin-left: 0px; margin-right: 0px;">
Chrome on OS X      
<img src="../images/blog/chrome-osx-emoji-png.png" alt="chrome osx emoji" title="chrome osx emoji" style="display: block; width: 90px; margin-left: 0px; margin-right: 0px;">


###å‚è€ƒè¿æ¥
[Emoji Unicode Tables](http://apps.timwhitlock.info/emoji/tables/unicode)     
[Segoe UI Symbol](https://msdn.microsoft.com/en-us/library/windows/apps/jj841126.aspx)     
[font-family MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/font-family)      
[font-family](http://www.w3schools.com/cssref/pr_font_font-family.asp)    










--------------------

https://technet.microsoft.com/en-us/library/ms189132(v=sql.105).aspx

dbæœ‰ä¸¤ç§å¹¶å‘æ§åˆ¶ï¼ˆconcurrency controlï¼‰ç­–ç•¥ã€‚æ§åˆ¶å¯¹åŒä¸€ä¸ªdatabase objectçš„ä¿®æ”¹ã€‚
æ‚²è§‚çš„åŠ é”ï¼ˆpessimistic lockingï¼‰
ä¸€ä¸ªç”¨æˆ·Aåœ¨ä¸€ä¸ªå¯¹è±¡ä¸Šæ‰§è¡ŒæŸäº›åŠ¨ä½œæ—¶ï¼ˆæ¯”å¦‚æ›´æ–°ï¼Œè¯»ï¼‰ä¼šè¢«åŠ ä¸Šé”ï¼Œå…¶å®ƒç”¨æˆ·ä¹Ÿå¯¹è¿™ä¸ªå¯¹è±¡æ‰§è¡ŒåŠ¨ä½œï¼Œå¦‚æœ
è¿™äº›åŠ¨ä½œå’Œç”¨æˆ·Açš„é”å‘ç”Ÿå†²çªï¼Œé‚£ä¹ˆå°±ä¸èƒ½æ‰§è¡Œè¿™äº›åŠ¨ä½œï¼›
ä¸ºä»€ä¹ˆå«æ‚²è§‚ï¼›
å› ä¸ºæ€»æ˜¯æƒ³ç€å…ˆåŠ é”ï¼›
é€‚ç”¨åœºæ™¯ï¼Œé«˜å¹¶å‘ï¼Œå‘ç”Ÿâ€œæ•°æ®ç«äº‰â€çš„å¯èƒ½æ€§é«˜ï¼›å¦‚æœç”¨ä¹è§‚é”ï¼ˆä¸åŠ é”ï¼‰å›æ»šæ¦‚ç‡é«˜ï¼Œå›æ»šå¤ªå¤šè¿˜ä¸å¦‚äº‹å…ˆå…ˆåŠ é”ï¼Œ
æ˜¯çš„æ“ä½œä¸²è¡ŒåŒ–
A system of locks prevents users from modifying data in a way that affects other users. After a user performs an action that causes a lock to be applied, other users cannot perform actions that would conflict with the lock until the owner releases it. This is called pessimistic control because it is mainly used in environments where there is high contention for data, where the cost of protecting data with locks is less than the cost of rolling back transactions if concurrency conflicts occur.



ä¹è§‚çš„åŠ é”ï¼ˆoptimistic lockingï¼‰
In optimistic concurrency control, users do not lock data when they read it. When a user updates data, the system checks to see if another user changed the data after it was read. If another user updated the data, an error is raised. Typically, the user receiving the error rolls back the transaction and starts over. This is called optimistic because it is mainly used in environments where there is low contention for data, and where the cost of occasionally rolling back a transaction is lower than the cost of locking data when read.
è¯»æ•°æ®ï¼Œæ—¶é—´ç‚¹tAï¼Œçš„æ—¶å€™ä¸åŠ é”ï¼›æ›´æ–°çš„æ—¶å€™ï¼Œå¦‚æœå‘ç°å…¶ä»–ç”¨æˆ·å·²ç»åœ¨æ—¶é—´ç‚¹tAä¹‹åå·²ç»ä¿®æ”¹äº†æ•°æ®ï¼Œé‚£ä¹ˆæ›´æ–°å¤±è´¥ï¼›
ä¸€èˆ¬æ¥è¯´ï¼Œå›æ»šåä¼šé‡è¯•ï¼›
ä¸ºä»€ä¹ˆä¹è§‚
å› ä¸ºè®¤ä¸ºæ²¡ä»€ä¹ˆç«äº‰ï¼Œä¸éœ€è¦åŠ é”ï¼ŒæˆåŠŸçš„å¯èƒ½æ€§å¤§
é€‚ç”¨åœºæ™¯ï¼Œä½ç«äº‰ï¼Œrollbackï¼ˆå¹¶é‡è¯•ï¼‰çš„ä»£ä»·æ¯”æ¯ä¸ªéƒ½åŠ é”è¦å°ï¼›


https://technet.microsoft.com/en-us/library/ms175519(v=sql.105).aspx

Shared Locks

Shared (S) locks allow concurrent transactions to read (SELECT) a resource under pessimistic concurrency control. For more information, see Types of Concurrency Control. No other transactions can modify the data while shared (S) locks exist on the resource. Shared (S) locks on a resource are released as soon as the read operation completes, unless the transaction isolation level is set to repeatable read or higher, or a locking hint is used to retain the shared (S) locks for the duration of the transaction.
Update Locks

Update (U) locks prevent a common form of deadlock. In a repeatable read or serializable transaction, the transaction reads data, acquiring a shared (S) lock on the resource (page or row), and then modifies the data, which requires lock conversion to an exclusive (X) lock. If two transactions acquire shared-mode locks on a resource and then attempt to update data concurrently, one transaction attempts the lock conversion to an exclusive (X) lock. The shared-mode-to-exclusive lock conversion must wait because the exclusive lock for one transaction is not compatible with the shared-mode lock of the other transaction; a lock wait occurs. The second transaction attempts to acquire an exclusive (X) lock for its update. Because both transactions are converting to exclusive (X) locks, and they are each waiting for the other transaction to release its shared-mode lock, a deadlock occurs.
To avoid this potential deadlock problem, update (U) locks are used. Only one transaction can obtain an update (U) lock to a resource at a time. If a transaction modifies a resource, the update (U) lock is converted to an exclusive (X) lock.
Exclusive Locks

Exclusive (X) locks prevent access to a resource by concurrent transactions. With an exclusive (X) lock, no other transactions can modify data; read operations can take place only with the use of the NOLOCK hint or read uncommitted isolation level.
Data modification statements, such as INSERT, UPDATE, and DELETE combine both modification and read operations. The statement first performs read operations to acquire data before performing the required modification operations. Data modification statements, therefore, typically request both shared locks and exclusive locks. For example, an UPDATE statement might modify rows in one table based on a join with another table. In this case, the UPDATE statement requests shared locks on the rows read in the join table in addition to requesting exclusive locks on the updated rows.

è¿˜è®²äº†å…¶ä»–çš„é”

http://www.objectdb.com/java/jpa/persistence/lock
ä¹è§‚é”å’Œæ‚²è§‚é”æ˜¯åº”ç”¨åœ¨database object levelä¸Šçš„ï¼›
time out

JPA 2 supports both optimistic locking and pessimistic locking. Locking is essential to avoid update collisions resulting from simultaneous updates to the same data by two concurrent users. 

Locking in ObjectDB (and in JPA) is always at the database object level, i.e. each database object is locked separately.

Optimistic locking is applied on transaction commit.
Any database object that has to be updated or deleted is checked. An exception is thrown if it is found out that an update is being performed on an old version of a database object, for which another update has already been committed by another transaction.

optimistic locking is enabled by default and fully automatic. Optimistic locking should be the first choice for most applications, since compared to pessimistic locking it is easier to use and more efficient.

In the rare cases in which update collision must be revealed earlier (before transaction commit) pessimistic locking can be used. When using pessimistic locking, database objects are locked during the transaction and lock conflicts, if they happen, are detected earlier.


This page covers the following topics:
Optimistic Locking
Pessimistic Locking
Other Explicit Lock Modes
Locking during Retrieval
Optimistic Locking
ObjectDB maintains a version number for every entity object. The initial version of a new entity object (when it is stored in the database for the first time) is 1. In every transaction in which an entity object is modified its version number is automatically increased by one. Version numbers are managed internally but can be exposed by defining a version field.

During commit (and flush), ObjectDB checks every database object that has to be updated or deleted, and compares the version number of that object in the database to the version number of the in-memory object being updated. The transaction fails and an OptimisticLockException is thrown if the version numbers do not match, indicating that the object has been modified by another user (using another EntityManager) since it was retrieved by the current updater.

Optimistic locking is completely automatic and enabled by default in ObjectDB, regardless if a version field (which is required by some ORM JPA providers) is defined in the entity class or not.

Pessimistic Locking
The main supported pessimistic lock modes are:

PESSIMISTIC_READ - which represents a shared lock.
PESSIMISTIC_WRITE - which represents an exclusive lock.
Setting a Pessimistic Lock
An entity object can be locked explicitly by the lock method:

  em.lock(employee, LockModeType.PESSIMISTIC_WRITE);
The first argument is an entity object. The second argument is the requested lock mode.

A TransactionRequiredException is thrown if there is no active transaction when lock is called because explicit locking requires an active transaction.

A LockTimeoutException is thrown if the requested pessimistic lock cannot be granted:

A PESSIMISTIC_READ lock request fails if another user (which is represented by another EntityManager instance) currently holds a PESSIMISTIC_WRITE lock on that database object.
A PESSIMISTIC_WRITE lock request fails if another user currently holds either a PESSIMISTIC_WRITE lock or a PESSIMISTIC_READ lock on that database object.
For example, consider the following code fragment:

  em1.lock(e1, lockMode1);
  em2.lock(e2, lockMode2);
em1 and em2 are two EntityManager instances that manage the same Employee database object, which is referenced as e1 by em1 and as e2 by em2 (notice that e1 and e2 are two in-memory entity objects that represent one database object).

If both lockMode1 and lockMode2 are PESSIMISTIC_READ - these lock requests should succeed. Any other combination of pessimistic lock modes, which also includes PESSIMISTIC_WRITE, will cause a LockTimeoutException (on the second lock request).

Pessimistic Lock Timeout
By default, when a pessimistic lock conflict occurs a LockTimeoutException is thrown immediately. The "javax.persistence.lock.timeout" hint can be set to allow waiting for a pessimistic lock for a specified number of milliseconds. The hint can be set in several scopes:

For the entire persistence unit - using a persistence.xml property:

    <properties>
       <property name="javax.persistence.lock.timeout" value="1000"/>
    </properties>
For an EntityManagerFactory - using the createEntityManagerFacotory method:

  Map<String,Object> properties = new HashMap();
  properties.put("javax.persistence.lock.timeout", 2000);
  EntityManagerFactory emf =
      Persistence.createEntityManagerFactory("pu", properties);
For an EntityManager - using the createEntityManager method:

  Map<String,Object> properties = new HashMap();
  properties.put("javax.persistence.lock.timeout", 3000);
  EntityManager em = emf.createEntityManager(properties);
or using the setProperty method:

  em.setProperty("javax.persistence.lock.timeout", 4000);
In addition, the hint can be set for a specific retrieval operation or query.

Releasing a Pessimistic Lock
Pessimistic locks are automatically released at transaction end (using either commit or rollback).

ObjectDB supports also releasing a lock explicitly while the transaction is active, as so:

  em.lock(employee, LockModeType.NONE);
Other Explicit Lock Modes
In addition to the two main pessimistic modes (PESSIMISTIC_WRITE and PESSIMISTIC_READ, which are discussed above), JPA defines additional lock modes that can also be specified as arguments for the lock method to obtain special effects:

OPTIMISTIC (formerly READ)
OPTIMISTIC_FORCE_INCREMENT (formerly WRITE)
PESSIMISTIC_FORCE_INCREMENT
Since optimistic locking is applied automatically by ObjectDB to every entity object, the OPTIMISTIC lock mode has no effect and, if specified, is silently ignored by ObjectDB.

The OPTIMISTIC_FORCE_INCREMENT mode affects only clean (non dirty) entity objects. Explicit lock at that mode marks the clean entity object as modified (dirty) and increases its version number by 1.

The PESSIMISTIC_FORCE_INCREMENT mode is equivalent to the PESSIMISTIC_WRITE mode with the addition that it marks a clean entity object as dirty and increases its version number by one (i.e. it combines PESSIMISTIC_WRITE with OPTIMISTIC_FORCE_INCREMENT).

Locking during Retrieval
JPA 2 provides various methods for locking entity objects when they are retrieved from the database. In addition to improving efficiency (relative to a retrieval followed by a separate lock), these methods perform retrieval and locking as one atomic operation.

For example, the find method has a form that accepts a lock mode:

  Employee employee = em.find(
      Employee.class, 1, LockModeType.PESSIMISTIC_WRITE);
Similarly, the refresh method can also receive a lock mode:

  em.refresh(employee, LockModeType.PESSIMISTIC_WRITE);
A lock mode can also be set for a query in order to lock all the query result objects.

When a retrieval operation includes pessimistic locking, timeout can be specified as a property. For example:

  Map<String,Object> properties = new HashMap();
  properties.put("javax.persistence.lock.timeout", 2000);
 
  Employee employee = em.find(
      Employee.class, 1, LockModeType.PESSIMISTIC_WRITE, properties);
 
  ...
 
  em.refresh(employee, LockModeType.PESSIMISTIC_WRITE, properties);
Setting timeout at the operation level overrides setting in higher scopes.